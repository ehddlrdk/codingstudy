# Array, LinkedList 구조 

## Array 
### |70|40|50|60|90|80|

* 논리적 저장순서와 물리적 저장 순서가 일치한다. 
* index로 해당 원소에 접근이 가능하다. random access가 가능하다.
* 배열의 중간 원소에 대해 삽입, 삭제시 shift를 해줘서 공간을 만들거나 빈공간을 채워야한다. 이때 O(n)의 시간이 소요됨.
* Array의 size는 선언 시점에 지정되어있어야함(정적 메모리 할당). Stack영역에 메모리 할당이 이루어진다.


## LinkedList
### null -> 70 -> 40 -> A -> null

* 자료의 주소 값으로 노드를 이용해 서로 연결되어 있는 구조를 갖는다.
* 삽입과 삭제의 경우 연결되어있는 노드를 서로 재연결 해주면 되기에 삽입 삭제 그 자체에 대해서는 Array에 비해서 속도가 빠르다.
* 원하는 값을 찾기 위해서는 리스트를 순회해야하기에 O(n)의 복잡도를 가지기에 크게 보면 삽입, 삭제시 Array와 속도가 비슷하다.
* Tree구조의 근간이 되는 자료구조이다.
* 새로운 node가 추가될 때 메모리 할당이 이루어진다(동적 메모리 할당). Heap영역에 메모리 할당이 이루어진다.
<br>

### 삽입과 삭제가 빈번하다면 LinkedList를 사용하는것이, 데이터의 접근이 더 중요하다면 Array를 사용하는것이 좋다.
<br>

# Stack, Queue 구조
## Stack
* 선형 자료구조의 일종으로 Last In First Out(LIFO) 구조를 가진다. 나중에 들어간 원소가 먼저 나온다.
* 깊이 우선 탐색(DFS Depth first Search)를 할 때 많이 이용된다. ex) 택배 상하차

## Queue
* 선형 자료구조의 일종으로 First In First Out(FIFO) 구조를 가진다. 먼저 들어간 원소가 먼저 나온다.
* 너비 우선 탐색(BFS Breadth First Search)를 할 때 많이 이용된다. ex) 최단길이, 은행 창구
<br>

# Tree
* 스택, 큐와 같은 선형 구조가 아닌 비선형 자료구조이다.
* 계층적 관계(Hierarchical Relationship)을 표현하는 자료구조이다. 
* 노드들의 집합으로 각 노드들은 서로 다른 자식을 가지며 반드시 하나의 root가 존재한다.

## Tree 용어
* Node(노드): 트리는 노드들의 집합으로 트리를 구성하는 것이다. Value값과 부모 자식의 정보를 가지고 있다.
* Edge(간선): 노드들을 연결하는 간선으로 부모 노드와 자식 노드를 연결하게 된다.
* Root Node(루트노드): 가장 최상위 노드로 부모를 가지지 않는다.
* Terminal Node(leaf node, 단말노드): 가장 하위 노드로 자식을 가지지 않는다.
* 깊이(depth): tree에서 부모에서 자식으로 이동할 때 depth가 1증가. 형제 노드 간의 depth는 동일, root node는 depth 0이다.

## Tree 종류
### Binary Tree (이진 트리)
* 루트노드를 중심으로 두개의 서브 트리로 나위어 진다. 모든 서브 트리도 이진 트리이어야 한다.
